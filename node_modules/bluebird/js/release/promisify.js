"use strict";
module.exports = function(Promise, INTERNAL) {
let THIS = {};
let util = require("./util");
let nodebackForPromise = require("./nodeback");
let withAppended = util.withAppended;
let maybeWrapAsError = util.maybeWrapAsError;
let canEvaluate = util.canEvaluate;
let TypeError = require("./errors").TypeError;
let defaultSuffix = "Async";
let defaultPromisified = {__isPromisified__: true};
let noCopyProps = [
    "arity",    "length",
    "name",
    "arguments",
    "caller",
    "callee",
    "prototype",
    "__isPromisified__"
];
let noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

let defaultFilter = function(name) {
    return util.isIdentifier(name) &&
        name.charAt(0) !== "_" &&
        name !== "constructor";
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    let val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (let i = 0; i < ret.length; i += 2) {
        let key = ret[i];
        if (suffixRegexp.test(key)) {
            let keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (let j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
                        .replace("%s", suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    let keys = util.inheritedDataKeys(obj);
    let ret = [];
    for (let i = 0; i < keys.length; ++i) {
        let key = keys[i];
        let value = obj[key];
        let passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

let escapeIdentRegex = function(str) {
    return str.replace(/([$])/, "\\$");
};

let makeNodePromisifiedEval;
if (!false) {
let switchCaseArgumentOrder = function(likelyArgumentCount) {
    let ret = [likelyArgumentCount];
    let min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(let i = likelyArgumentCount - 1; i >= min; --i) {
        ret.push(i);
    }
    for(let i = likelyArgumentCount + 1; i <= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

let argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, "_arg", "");
};

let parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), "_arg", "");
};

let parameterCount = function(fn) {
    if (typeof fn.length === "number") {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn, _, multiArgs) {
    let newParameterCount = Math.max(0, parameterCount(fn) - 1);
    let argumentOrder = switchCaseArgumentOrder(newParameterCount);
    let shouldProxyThis = typeof callback === "string" || receiver === THIS;

    function generateCallForArgumentCount(count) {
        let args = argumentSequence(count).join(", ");
        let comma = count > 0 ? ", " : "";
        let ret;
        if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
        } else {
            ret = receiver === undefined
                ? "ret = callback({{args}}, nodeback); break;\n"
                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
        }
        return ret.replace("{{args}}", args).replace(", ", comma);
    }

    function generateArgumentSwitchCase() {
        let ret = "";
        for (let i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] +":" +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += "                                                             \n\
        default:                                                             \n\
            let args = new Array(len + 1);                                   \n\
            let i = 0;                                                       \n\
            for (let i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis
                                ? "ret = callback.apply(this, args);\n"
                                : "ret = callback.apply(receiver, args);\n"));
        return ret;
    }

    let getFunctionCode = typeof callback === "string"
                                ? ("this != null ? this['"+callback+"'] : fn")
                                : "fn";
    let body = "'use strict';                                                \n\
        let ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            let len = arguments.length;                                      \n\
            let promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            let nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            let ret;                                                         \n\
            let callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
        .replace("[GetFunctionCode]", getFunctionCode);
    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
    return new Function("Promise",
                        "fn",
                        "receiver",
                        "withAppended",
                        "maybeWrapAsError",
                        "nodebackForPromise",
                        "tryCatch",
                        "errorObj",
                        "notEnumerableProp",
                        "INTERNAL",
                        body)(
                    Promise,
                    fn,
                    receiver,
                    withAppended,
                    maybeWrapAsError,
                    nodebackForPromise,
                    util.tryCatch,
                    util.errorObj,
                    util.notEnumerableProp,
                    INTERNAL);
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
    let defaultThis = (function() {return this;})();
    let method = callback;
    if (typeof method === "string") {
        callback = fn;
    }
    function promisified() {
        let _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        let promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        let cb = typeof method === "string" && this !== defaultThis
            ? this[method] : callback;
        let fn = nodebackForPromise(promise, multiArgs);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
        return promise;
    }
    util.notEnumerableProp(promisified, "__isPromisified__", true);
    return promisified;
}

let makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
    let suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
    let methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (let i = 0, len = methods.length; i < len; i+= 2) {
        let key = methods[i];
        let fn = methods[i+1];
        let promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] =
                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
            let promisified = promisifier(fn, function() {
                return makeNodePromisified(key, THIS, key,
                                           fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj[promisifiedKey] = promisified;
        }
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver, multiArgs) {
    return makeNodePromisified(callback, receiver, undefined,
                                callback, null, multiArgs);
}

Promise.promisify = function (fn, options) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    if (isPromisified(fn)) {
        return fn;
    }
    options = Object(options);
    let receiver = options.context === undefined ? THIS : options.context;
    let multiArgs = !!options.multiArgs;
    let ret = promisify(fn, receiver, multiArgs);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    options = Object(options);
    let multiArgs = !!options.multiArgs;
    let suffix = options.suffix;
    if (typeof suffix !== "string") suffix = defaultSuffix;
    let filter = options.filter;
    if (typeof filter !== "function") filter = defaultFilter;
    let promisifier = options.promisifier;
    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }

    let keys = util.inheritedDataKeys(target);
    for (let i = 0; i < keys.length; ++i) {
        let value = target[keys[i]];
        if (keys[i] !== "constructor" &&
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier,
                multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
};
};

